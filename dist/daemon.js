"use strict";
/**
 * Signal CLI Daemon Management
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.spawnSignalDaemon = spawnSignalDaemon;
exports.waitForSignalDaemonReady = waitForSignalDaemonReady;
const node_child_process_1 = require("node:child_process");
const client_js_1 = require("./client.js");
function classifySignalCliLogLine(line) {
    const trimmed = line.trim();
    if (!trimmed)
        return null;
    // signal-cli commonly writes all logs to stderr; treat severity explicitly.
    if (/\b(ERROR|WARN|WARNING)\b/.test(trimmed))
        return "error";
    // Some signal-cli failures are not tagged with WARN/ERROR
    if (/\b(FAILED|SEVERE|EXCEPTION)\b/i.test(trimmed))
        return "error";
    return "log";
}
function buildDaemonArgs(opts) {
    const args = [];
    if (opts.account) {
        args.push("-a", opts.account);
    }
    args.push("daemon");
    args.push("--http", `${opts.httpHost}:${opts.httpPort}`);
    args.push("--no-receive-stdout");
    if (opts.receiveMode) {
        args.push("--receive-mode", opts.receiveMode);
    }
    if (opts.ignoreAttachments)
        args.push("--ignore-attachments");
    if (opts.ignoreStories)
        args.push("--ignore-stories");
    if (opts.sendReadReceipts)
        args.push("--send-read-receipts");
    return args;
}
function spawnSignalDaemon(opts) {
    const args = buildDaemonArgs(opts);
    const child = (0, node_child_process_1.spawn)(opts.cliPath, args, {
        stdio: ["ignore", "pipe", "pipe"],
    });
    const log = opts.runtime?.log ?? (() => { });
    const error = opts.runtime?.error ?? (() => { });
    child.stdout?.on("data", (data) => {
        for (const line of data.toString().split(/\r?\n/)) {
            const kind = classifySignalCliLogLine(line);
            if (kind === "log")
                log(`signal-cli: ${line.trim()}`);
            else if (kind === "error")
                error(`signal-cli: ${line.trim()}`);
        }
    });
    child.stderr?.on("data", (data) => {
        for (const line of data.toString().split(/\r?\n/)) {
            const kind = classifySignalCliLogLine(line);
            if (kind === "log")
                log(`signal-cli: ${line.trim()}`);
            else if (kind === "error")
                error(`signal-cli: ${line.trim()}`);
        }
    });
    child.on("error", (err) => {
        error(`signal-cli spawn error: ${String(err)}`);
    });
    return {
        pid: child.pid ?? undefined,
        stop: () => {
            if (!child.killed) {
                child.kill("SIGTERM");
            }
        },
    };
}
async function waitForSignalDaemonReady(baseUrl, timeoutMs = 30_000, runtime) {
    const startTime = Date.now();
    const log = runtime?.log ?? (() => { });
    const error = runtime?.error ?? (() => { });
    log(`Waiting for Signal daemon at ${baseUrl}...`);
    while (Date.now() - startTime < timeoutMs) {
        const res = await (0, client_js_1.signalCheck)(baseUrl, 1000);
        if (res.ok) {
            log("Signal daemon ready");
            return;
        }
        // Log after 5 seconds, then every 5 seconds
        const elapsed = Date.now() - startTime;
        if (elapsed > 5000 && elapsed % 5000 < 1000) {
            error(`Still waiting for Signal daemon... (${res.error})`);
        }
        await new Promise((r) => setTimeout(r, 150));
    }
    throw new Error(`Signal daemon did not become ready within ${timeoutMs}ms`);
}
//# sourceMappingURL=daemon.js.map